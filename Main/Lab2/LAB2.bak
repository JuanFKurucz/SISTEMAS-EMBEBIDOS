#use IO.LIB
#use BTN.LIB
#use LED.LIB
#use UTILITIES.LIB
#define MAX_EVENTOS 10
#define MAX_TEXTO 10
#define MAX_TIME 32767

// Definimos los eventos
typedef struct Events{
	char command;
	char param;
	unsigned long time;
} Event;

// Funcion que inicializa los eventos con los valores time, param en 0 y command en 0xFF
iniciar_eventos(Event eventos[]){
	int i;
	for(i=0;i<MAX_EVENTOS;i++){
		eventos[i].time = 0;
		eventos[i].param = 0;
		eventos[i].command = 0xFF;
	}
}

// Funcion que corre durante toda la ejecucion de nuestro programa,
// buscando eventos que esten activos para ejecutarlos en el tiempo correspondiete
// Nuestros eventos se activan una vez que command deja de ser 0xFF
consumir_eventos(Event eventos[]){
	int i;
	for(i=0;i<MAX_EVENTOS;i++){
		if(eventos[i].command != 0xFF && eventos[i].time == read_rtc()){
			if(eventos[i].command=='1'){
				LED_SET(eventos[i].param);
			} else {
				LED_RESET(eventos[i].param);
			}
		}
	}
}

//funcion que obtiene a partir de un ano, mes y dia los segundos
//Tiene en cuenta la cantidad de dias del mes y si el ano es bisiesto
unsigned long convertir_time(char* ano, char* mes, char* dia){
   int numeroAno;
	int numeroMes;
	int numeroDia;
   struct tm fecha;

	numeroAno = atoi(ano);
	numeroMes = atoi(mes);
	numeroDia = atoi(dia);
	if((int)numeroAno<=0){
		return -1;
	}
	if((int)numeroMes<=0 || (int)numeroMes>12){
		return -2;
	}
	if((int)numeroDia<=0){
		return -3;
	}
   fecha.tm_year = numeroAno;
   fecha.tm_mon = numeroMes;
   fecha.tm_mday = numeroDia;
   fecha.tm_sec=0;
   fecha.tm_min=0;
   fecha.tm_hour=0;
   printf("%d/%d/%d %d:%d:%d",fecha.tm_year,fecha.tm_mon,fecha.tm_mday,fecha.tm_hour,fecha.tm_min,fecha.tm_sec);
	write_rtc(mktime(&fecha));
	return 0;
}

main()
{
	Event eventos[MAX_EVENTOS];
	int i;
	char texto[MAX_TEXTO];
	char texto2[MAX_TEXTO];
	char command;
	char param;
	int response;
	int ev;
	char ano[MAX_TEXTO];
	char mes[MAX_TEXTO];
	char dia[MAX_TEXTO];
   char buffer[20];
	unsigned long time;
	int posicion;
   struct tm fecha;
	HW_init();
	iniciar_eventos(eventos);
	while(1){
		//Durante la ejecucion de nuestro programa prendemos y apagamos el led rojo
		costate{
			LED_ROJO_SET();
			waitfor(DelayMs(400));
			LED_ROJO_RESET();
			waitfor(DelayMs(800));
		}

		costate{
			consumir_eventos(eventos);
		}
		//En este costate tenemos un menu para el usuario, con un switch y los diferentes casos posibles
		costate{
			printf("\nIngrese 1 para Fijar la hora del reloj de tiempo real (RTC) del Rabbit\n");
			printf("Ingrese 2 para Consultar la hora del RTC del Rabbi\n");
			printf("Ingrese 3 para Agregar un evento de calendario.\n");
			printf("Ingrese 4 para Quitar un evento de calendario.\n");
			printf("Ingrese 5 para Consultar la lista de eventos de calendario activos.\n");
			waitfor(getswf(texto)); //Esperar a que el usuario ingrese una opcion
			switch(texto[0]){
				//Para pasar el sting a time utilizamos la funcion getswf
				//Para fijar la hora del reloj utilizamos la funcion write_rtc
				case '1':
				printf("Ingrese el ano\n");
				waitfor(getswf(ano));

				printf("Ingrese el mes\n");
				waitfor(getswf(mes));

				printf("Ingrese el dia\n");
				waitfor(getswf(dia));

				time=convertir_time(ano, mes, dia);
				if(time==-1){
					printf("El ano ingresado es incorrecto\n");
				} else if (time == -2){
					printf("El mes ingresado es incorrecto\n");
				} else if (time == -3){
					printf("El dia ingresado es incorrecto\n");
				} else if(time >= 0) {
               printf("Fecha actualizada\n");
				} else {
					printf("La fecha se va del rango soportado  %ld\n",time);
				}
				break;
				//Para consultar la hora de la placa utilizamos la funcion read_rtc
				case '2':
               mktm(&fecha,read_rtc());
      			printf("%d/%d/%d %d:%d:%d",fecha.tm_year,fecha.tm_mon,fecha.tm_mday,fecha.tm_hour,fecha.tm_min,fecha.tm_sec);
				break;
				case '3':
				posicion=-1;
				for(i=0;i<MAX_EVENTOS;i++){
					if(eventos[i].command == 0xFF){
						posicion=i;
						break;
					}
				}
				//Como definimos MAX_EVENTOS en 10, tenemos que controlar que el usuario no supere ese limite
				//Para que el evento quede correctamente definido, esperamos a tener todos los parametros que el usuario ingrese
				//verificando que sean correctos y luego lo creamos
				//De no realizar esto el programa prodria llevar a dar problemas, si se intenta listar un evento que todavia no tenga
				//todos sus datos
				if(posicion==-1){
					printf("Capacidad maxima de eventos alcanzada");
				} else {
					printf("Ingrese 1 para prender o ingrese 0 para apagar\n");
					waitfor(getswf(texto2));
					command = texto2[0];

					printf("Ingrese el numero de led\n");
					waitfor(getswf(texto2));
					param = texto2[0];

					printf("Ingrese el tiempo en el que ejecutar\n");
					waitfor(getswf(texto2));
					time = atoi(texto2);
					// Este if es para controlar los datos que el usuario ingresa
					if((command == '1' || command == '0') && (param>='0' && param <='7') && (time <= MAX_TIME)){
						eventos[posicion].command = command;
						eventos[posicion].param = param;
						eventos[posicion].time = time;
						command = 0;
						param = 0;
						time = 0;
					} else {
						printf("Datos erroneos\n");
					}
				}
				break;
				case '4':
				printf("Inserte el indice del evento a eliminar\n");
				posicion=-1;
				waitfor(getswf(texto2));
				posicion = atoi(texto2);
				//Controlamos que el usuario no se vaya de rango para eliminar un evento
				if(posicion>=0 && posicion < MAX_EVENTOS){
					//Lo que hacemos para eliminar nuestro evento es volver a setear los datos como en el estado inicial
					eventos[posicion].command = 0xFF;
					eventos[posicion].param = 0;
					eventos[posicion].time = 0;
				} else {
					printf("El indice se va de rango de la lista de eventos\n");
				}
				break;
				case '5':
				//Recorremos todos los eventos buscando unicamente los que se encuentren activos
				//y los imprimimos por consola
				for(i=0;i<MAX_EVENTOS;i++){
					if(eventos[i].command == 0xFF){
						printf("%d: Evento no definido\n",i);
					} else {
						printf("%d: Accion: %c, Bit: %c, Tiempo: %d\n",i,eventos[i].command,eventos[i].param,eventos[i].time);
					}
				}
				break;
				default:
				printf("Comando no encontrado");
			}
		}
	}

}